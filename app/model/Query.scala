package model

import java.io.{File, FileInputStream, ObjectInputStream}

import LSH.hashFunctions.{CrossPolytope, Hyperplane}
import LSH.structures.{HashTable, LSHStructure}
import tools.Cosine
import IO.Parser

import scala.collection.mutable.ArrayBuffer
import scala.util.Random

/**
  * Created by remeeh on 02-11-2016.
  */

object Query {
  // Load LSHStructure
  // TODO Get path
/*  val ois = new ObjectInputStream(new FileInputStream("data/Hyperplane_16_11.lshstructure"))
  println("Loading started!")
  val lshs: LSHStructure = ois.readObject.asInstanceOf[LSHStructure]
  ois.close()*/
  // TODO CHANGE THIS !!!!
  val seed:Long = System.currentTimeMillis()
  val rnd = new Random(seed)

  // new Build method
  val lshs = new LSHStructure(for {
    i <- 0 until 4
    parser <- List(new Parser(new File("data/descriptors-decaf-random-sample-reduced-20000000.data")))
    //parser <- List(new Parser(new File("data/descriptors-mini-reduced.data")))
    table <- {
      val t = new HashTable(() => new Hyperplane(10, () => new Random(rnd.nextLong())))
      for (j <- 0 until parser.size) {
        t += parser.next
      }
      List(t)
    }
  } yield table)

  println("Structure finished")

  // return the result generated by
  def getResults(imageId:String, range:Double) : (String, List[((String, Vector[Float]), Double)]) = {

    val fVector = lshs.findVectorById(imageId)
    val tres = time {
      lshs.query(fVector, range, Cosine)
    }

    val res2 = tres._1.zip(tres._1.map(x => Cosine.measure(fVector._2, x._2))).sortBy(_._2)
    (tres._2, res2.toList)

  }

  def time[R](block: => R) = {
    val t0 = System.currentTimeMillis()
    val result = block    // call-by-name
    val t1 = System.currentTimeMillis()
    (result, ((t1 - t0) + "ms"))
  }

}
